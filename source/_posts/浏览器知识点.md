---
title: 浏览器知识点
date: 2023-08-14 10:12:26
tags:
---
## 从输入url到看到界面的过程

1. 检查缓存
   ```
   如果本地浏览器有本地的静态资源缓存，且未过期，则直接从缓存中读取，而不会发送网络请求。
   ```
2. DNS解析
    ```
    将输入的url对应的域名解析成ip，DNS解析过程根据
        本机的hosts文件
        本地DNS缓存
        本地域名服务器
    的优先级解析域名。在域名解析过程还可能涉及和顶级域名服务器的交互。
    ```

3. 发送HTTP请求

    ```
    建立TCP连接，如果是HTTPS还需要建立TLS连接，然后发送HTTP请求，
    并接收相应，如果相应状态码为301/302还需要进行重定向。
    ```

4. 将响应数据提交给渲染进程处理

    ```
    渲染进程解析HTML，在这个过程中，会提前解析外链（link和script）并提前下载。
    ```

5. 构建DOM

    ```
    将HTML数据转换为DOM。
    ```

6. 样式计算

    ```
    将CSS转换为CSSOM（document.styleSheets），并使用CSSOM，
    根据继承规则和层叠规则， 计算每个DOM节点的具体样式，得到ComputedStyle树。
    ```

7. 布局

    ```
    根据DOM树和ComputedStyle，计算所有可见元素的坐标，生成一个新的树：布局树。
    ```

8. 分层
    ```
    根据布局树生成不同的图层，得到分层树(LayerTree)。
    ```
9.  绘制
    ```
    对每个层生成绘制指令。然后渲染引擎将绘制指令提交给合成线程处理。
    ```
10. 分块
    ```
    合成线程会先将每个图层分块(tile)，优先渲染视口附近的块。合成线程把tile提供给栅格化线程。
    ```

11. 栅格化
     ```
     栅格化线程把每个块转成位图，并写道显存中。一旦所有图块都被栅格化，
    合成线程就会生成一个绘制图块的命令——"DrawQuad"，然后将该命令提交给浏览器进程。
    "DrawQuad"是一系列的指令，这些指令引用了显存中的tile位图。
     ```
12. 合成
     ```
     浏览器进程接收到DrawQuad，并用指令将tile合成完整的帧，
    然后调用GPU进程将合成后的帧绘制到屏幕上。
     ```  
    
## 浏览器缓存
### 1.缓存位置
从缓存位置上来分有四种，优先级从上到下
1. `Service Worker`: 持续性缓存
2. `Memory Cache`：读取速度快，缓存持续性短（随着进程释放），可使用空间小
3. `Disk Cache`：读取速度慢，胜在容量和时效，根据相应头来判断缓存哪些资源等
4. `Push Cache`：HTTP/2中的内容，时间短，只在会话中存在

如果上面四个缓存都没有命中，才会去发网络请求
### 2.缓存策略
缓存策略可以分为**强缓存**和**协商缓存**
#### 强缓存
强缓存可以通过设置两种`HTTP Header`来实现，包括：
- Expires  
  为资源设置一个过期时间，如果资源过期了则需要重新请求。  
  **缺陷：**  
  修改本地时间可能会使缓存失效
- Cache-Control  
  优先级高于Expires。可以在请求头或响应头中设置，并且可以组合使用多种指令。  
  **可以设置**  
  缓存失效时间、客户端和代理服务器都能缓存等

强缓存在缓存期间不需要请求，`state code`为**200**
#### 协商缓存
如果缓存过期了，就**需要发起请求验证资源是否有更新**。协商缓存可以通过设置两种头实现：  
`Last-Modified`和`ETag`  
当浏览器发起请求验证资源时，如果资源没有做改变，那么服务器就会返回304状态码，并且更新浏览器缓存有效期。

## 浏览器同源策略  
概念：**源 = 协议 + 主机 + 端口**，两个源相同，则为同源；反之为跨源或者跨域。

同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制。

解决方案：配置代理、JSONP、CORS

## 网络攻击  
### CSRF（Cross-site Request Forgery） 跨站请求伪造  
CSRF 是跨站请求伪造，是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法

它首先引导用户访问一个危险网站，当用户访问网站后，网站会发送请求到被攻击的站点，这次请求会携带用户的cookie发送，因此就利用了用户的身份信息完成攻击

攻击方式：
1. 使用img的src // 无法发Post请求
2. 使用form的action // 可以发Post请求，但用户有感知（页面会跳转）
3. iframe的src // 用户没有感知

防御手段：
1. 不使用cookie // 兼容性差 // ssr会遇到困难，但是可以解决
2. cookie中使用sameSite字段 // 兼容性差 // 容易挡住自己人
3. 使用token校验 // 如果用户拿到token点到了危险网站，可能会发危险请求并携带token
4. 服务器检查referer字段 // 现在已经很少用，有漏洞 (使用base64不会携带referer)

扩展： cookie能添加哪些字段？
1. sameSite=strict // 所在的页面必须是相同的站点才能发请求
sameSite=Lax // 由于strict太严格，用Lax则只会限制某些请求，比如Post
2. name //名称
3. value //cookie的值
4. httponly // 如果设为true，则只有http请求会携带cookie
5. expires / max-age // cookie的过期时间，不设置则默认值是session
6. secure //是否只能通过https来传递cookie
7. path // 可以访问此cookie的页面路径，如`/test`

### xss （Cross-site Scripting） 跨站脚本攻击  
攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。  

防御：  
服务端对用户提交的内容进行过滤或者编码  
- 过滤：去掉一些危险的标签，去掉一些危险的属性
- 对危险的标签进行HTML实体编码 // 比如script标签，让它变成一段String

## requestIdleCallback和requestAnimationFrame的异同
区别
- `requestAnimationFrame`每次渲染完执行，优先级高
- `requestIdleCallback`空闲时才执行，优先级低

共同点
- 都是宏任务，需要等DOM渲染完后再执行  

## script标签的defer和async有什么区别  
- script：HTML暂停解析，下载JS，执行JS，在继续解析HTML。
- defer：HTML继续解析，并行下载JS，HTML解析完在执行JS（不用把script放到body后面，我们在head中\<script defer\>让js脚本并行加载会好点）
- async：HTML继续解析，并行下载JS，执行JS（加载完毕后立即执行），在继续解析HTML  

## prefetch和dns-prefetch分别是什么  
- preload 资源在当前页面使用，会优先加载
- prefetch 资源在未来页面使用，空闲时加载

## 浏览器进程  
浏览器中，最主要的进程有：
1. 浏览器进程  
主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。
2. 网络进程  
负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。
3. 渲染进程  
渲染进程启动后，会开启一个**渲染主线程**，主线程负责执行HTML、CSS、JS代码。  
默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。  

补充知识： 目前的浏览器想改变这种渲染进程模式，因为每个Tab开一个进程资源消耗太大了。（目前谷歌文档说同一个域名下的网页作为一个进程）

